include("../tools/imports.jl")
#Fig. 10

WD_PDF(x) = 27/8 * (x+x^2)/(1+x+x^2)^(5/2)
WD_PDF_adj(x) = WD_PDF(x) + B/(1+x)^2*(1/(x+1/x)-A*1/(x+1/x)^2)

WD_CDF(x) = 1/4*(2+(1+2x)*(x^2+x-2)/(1+x+x^2)^(3/2))

B = 0.233378
A = 2*(π-2)/(4-π)

δWD(x) = 1/4*B*(-2*(1+A)+(2+A)/(1+x)+A/(1+x^2)+(2+A)*atan(x))
WD_CDF_adj(x) = 1/4*(2+(1+2x)*(x^2+x-2)/(1+x+x^2)^(3/2)) + δWD(x)

#baseline accuracy since WD is not exact
dist = []
for i in ProgressBar(1:2^10)
	O = randn(2^10, 2^10)
	vals = svdvals(O)
	spacs = spacings(vals)
	push!(dist, spacs...)
end

#Top panel

function get_dist_dkl(dist)
	distmax = 5 #power-law distribution is hard to estimate accurately, need to introduce a cutoff
	binnum = 2*sum(dist .< distmax)^(1/3)
	step = distmax / binnum
	bins = (0:binnum)*step
	P = float.(StatsBase.fit(Histogram, dist, bins).weights) ./ length(dist)
	Q = [WD_CDF_adj(bins[i+1])-WD_CDF_adj(bins[i]) for (i,b) in enumerate(bins[1:end-1])]
	P ./= sum(P)
	Q ./= sum(Q)
	s(x,y) = x == 0 ? 0 : x*log(x/y)
	sum(s.(P,Q))
end

dkl_minerr = get_dist_dkl(dist) #should be aroudn 1E-4

function get_data(n, nh)
	#data generated by cluster/sparse_op_arrow.jl
	[copy(col) for col in Arrow.Table("/home/benm/Documents/repos/AutomataOperatorEntanglement/data/sparse_Rx/X_N$(n)_nH$(nh).arrow")]
end

p = plot(palette = :seaborn_deep)
for n in 6:2:12
	dkls = [get_dist_dkl(vcat(spacings.(get_data(n, nh); prec = 6)...)) for nh in 1:n]
	stderr(x) = std(x)/sqrt(length(x))
	regroup(dist, nb) = [vcat(dist[(i-1)*nb+1:i*nb]...) for i in 1:Int(length(dist)/nb)]
	stds = [stderr(get_dist_dkl.(regroup(vcat(spacings.(get_data(n,nh))), 16))) for nh in 1:n]
	x = 1:n
	plot!(x, dkls, yaxis = :log,  marker = :o, linewidth = 2, yerr = stds, label = "N=$(n)")
end
hline!([dkl_minerr], color = :black, linestyle = :dash, label = "GUE (numerics)")
xticks!(1:12)
xlabel!(L"n_H")
ylabel!(L"D_{\text{KL}}(\text{spacings} || \text{WD})")
savefig("figures/fig10_panel1.svg")

#spacing comparison inset
function get_data(n, nh)
	#data generated by cluster/sparse_op_csv.jl
	f = open("/home/benm/Documents/repos/AutomataOperatorEntanglement/data/sparse_H/X_N$(n)_nH$(nh).csv", read = true)
	d = read(f, String)
	dat = split(d, "sample")[2:end]
	[parse.(Float64, split(d, "\n")[2:end-1]) for d in dat]
end
dat1 = vcat(spacings.(get_data(12,12))...)
dat2 = vcat(spacings.([copy(col) for col in Arrow.Table("/home/benm/Documents/repos/AutomataOperatorEntanglement/data/sparse_Rx/X_N12_nH12.arrow")])...)

h1 = StatsBase.fit(Histogram,dat1[dat1 .<= 25], nbins = 400)
h2 = StatsBase.fit(Histogram,dat2[dat2 .<= 25], nbins = 400)

c1 = seaborn[1]
c2 = seaborn[4]

plot(LinRange(0, 5, 500), WD(1), linewidth = 2, color = c2, label = L"\text{WD},\beta = 1")
plot!(LinRange(0, 5, 500), WD(0), linewidth =2, color=c1, label = L"p_{GOE}")

scatter!(collect(h1.edges[1]) .+ (.5*25/length(h1.weights)), h1.weights ./ length(dat1) * length(h1.weights)/25, color = c1, label = L"sparse $H$", markersize = 8)
scatter!(collect(h2.edges[1]) .+ (.5*25/length(h2.weights)), h2.weights ./ length(dat2) * length(h2.weights)/25, color = c2, label = L"sparse $R_x$", markersize = 8)

xlims!(0, 4)
xlabel!(L"r")
ylabel!(L"p(r)")

savefig("figures/fig10_panel1_inset.svg")

#Second panel
function get_data(n, nh)
	#data generated by cluster/sparse_op_arrow.jl
	[copy(col) for col in Arrow.Table("/home/benm/Documents/repos/AutomataOperatorEntanglement/data/sparse_Rx/Z_N$(n)_nH$(nh).arrow")]
end

p = plot(palette = :seaborn_deep)
for n in 6:2:12
	dkls = [get_dist_dkl(vcat(spacings.(get_data(n, nh); prec = 6)...)) for nh in 1:n]
	stderr(x) = std(x)/sqrt(length(x))
	regroup(dist, nb) = [vcat(dist[(i-1)*nb+1:i*nb]...) for i in 1:Int(length(dist)/nb)]
	stds = [stderr(get_dist_dkl.(regroup(vcat(spacings.(get_data(n,nh))), 16))) for nh in 1:n]
	x = 1:n
	plot!(x, dkls, yaxis = :log,  marker = :o, linewidth = 2, yerr = stds, label = "N=$(n)")
end
hline!([dkl_minerr], color = :black, linestyle = :dash, label = "GUE (numerics)")
xticks!(1:12)
xlabel!(L"n_H")
ylabel!(L"D_{\text{KL}}(\text{spacings} || \text{WD})")
savefig("figures/fig10_panel2.svg")